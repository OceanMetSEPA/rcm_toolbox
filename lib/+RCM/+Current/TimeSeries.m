classdef TimeSeries < RCM.TimeSeries.TotalTide ... % Abstract classes first
        & RCM.Current.TimeSeries.Plotter ...
        & RCM.TimeSeries.Base
    
    % Class for representing and manipulating current timeseries data.
    % Instances are created by passing in three vectors representing 
    %
    %   - time
    %   - speed
    %   - direction
    %
    % The current vectors are decomposed into their constituent u and v
    % components, and stored on the .u and .v properties. A number of descriptive 
    % statistics and a harmonic analysis of the data can be easily done.
    % There are useful methods for generating plots and contextualising
    % the data using Total Tide.
    %
    % Object properties are also available for storing other commonly
    % useful data such as a corresponding presure record (.Pressure), the RCM easting 
    % (.Easting) and northing (.Northing), and the height above the sea bed
    % of the respective RCM bin (.HeightAboveBed). The class extends
    % *dynamicprops* and therefore any other properties can be added
    % arbitrarily when needed.
    %
    % Usage:
    %
    %    C = RCM.Current.TimeSeries(time, speed, direction);
    %
    % where dateTime, speed, direction are vectors describing the time (as
    %       datenums), speed and direction of currents
    % 
    %
    % EXAMPLES:
    %
    %   currents = RCM.Current.TimeSeries(timeVector, speedVector, directionVector)
    %   currents.Time
    %     ans =
    %               735168.477083333
    %               735168.490972222
    %               735168.504861111
    %               ...
    %
    %   currents.Speed
    %     ans =
    %               0.0467
    %               0.1099
    %               0.0548
    %               ...
    %
    %   currents.Direction
    %     ans =
    %               212.75
    %               171.83
    %               108.27
    %               ...
    %  
    %   currents.u
    %     ans =
    %            -0.0252635078128853
    %             0.0156179624742282
    %             0.0520375184947972
    %             ...
    %
    %   currents.v
    %     ans =
    %            -0.0392765219054371
    %             -0.108784600234379
    %            -0.0171795421622242
    %             ...
    %
    %      
    %  ## Statistics ##
    %
    %  Summary statistics are generated which can be accessed via the following fields
    %
    %   currents.MeanSpeed
    %   currents.MajorAxis
    %   currents.ParallelAmplitude
    %   currents.NormalAmplitude
    %   currents.AmplitudeAnisotropy
    %   currents.ResidualSpeed
    %   currents.ResidualDirection
    %
    %  Some other derivations from the data can be accessed using these
    %  methods:
    %
    %   currents.percentLessThan()
    %   currents.normalisedComponents()
    %   currents.cumulativeVector()
    %
    %  ## Harmonics ##
    %
    %  A harmonic analysis can be generated by running the following
    %  method
    %
    %   currents.calculateHarmonics() 
    %   
    %  and the results can be accessed via the following fields
    %
    %   currents.TideCoefficients
    %   currents.TideReconstructedComponents
    %   currents.uTidal
    %   currents.vTidal
    %   currents.uNonTidal
    %   currents.vNonTidal
    %   currents.SpeedTidal
    %   currents.DirectionTidal
    %   currents.Tideyness
    %
    %  NOTE: harmonic analysis requires a latitude, which needs to be set
    %  using either the .Latitude property explicity or by setting the 
    %  .Easting and .Northing properties.
    %
    %  ## Plots ##
    %
    %  A number of standard plots can be easily generated using the
    %  following methods
    %   
    %   currents.scatterPlot
    %   currents.normalisedScatterPlot
    %   currents.cumulativeVectorPlot
    %
    %
    % DEPENDENCIES:
    %
    % - UTide
    % - +TotalTide/
    % - +RCM/+Utils
    % - OS.catCoordinates.m
    % - greatCircleDistance.m
    %
    
    properties (SetAccess = public, GetAccess = public)  
        % required for instantiation
        Speed@double     = [];
        Direction@double = [];
        
        % optional
        Pressure@double = [];
        HeightAboveBed = NaN;
        
        % Components - derived
        u@double = [];
        v@double = [];
        ParallelComponent@double = [];
        NormalComponent@double   = [];
        
        % Stats - derived
        MeanSpeed@double            = NaN;
        MajorAxis@double            = NaN;
        ParallelAmplitude@double    = NaN;
        NormalAmplitude@double      = NaN;
        AmplitudeAnisotropy@double  = NaN;
        ResidualSpeed@double        = NaN;
        ResidualDirection@double    = NaN;
        
        ResidualConsistentMajorAxis@double = NaN;
        ResidualMajorAxisAngle@double      = NaN;
        
        % Tide - derived
        TideCoefficients = [];
        uTidal@double          = [];
        vTidal@double          = [];
        uNonTidal@double       = [];
        vNonTidal@double       = [];
        SpeedTidal@double      = [];
        DirectionTidal@double  = [];
        Tideyness@double       = NaN;
    end
    
    methods(Static = true)
        
        function TS = create(time, speed, direction)
            TS = RCM.Current.TimeSeries;
            
            TS.Time      = time;
            TS.Speed     = speed;
            TS.Direction = direction;
            
            TS.calculateComponents;
        end
        
        function TS = createFromComponents(time, u, v)
            TS = RCM.Current.TimeSeries;
            
            TS.Time = time;
            TS.u    = u;
            TS.v    = v;
            
            TS.calculateSpeed;
        end
        
        function ts = fromStruct(s)
            ts = RCM.Current.TimeSeries.create(s.Time, s.Speed,s.Direction);

            ts.Pressure       = s.Pressure;
            ts.Easting        = s.Easting;
            ts.Northing       = s.Northing;
            ts.HeightAboveBed = s.HeightAboveBed;
        end
           
    end
    
    methods
        
        function u = get.u(TS)
            if isempty(TS.u) | isnan(TS.u)
                TS.calculateComponents;
            end
            
            u = TS.u;
        end
        
        function v = get.v(TS)
            if isempty(TS.v) | isnan(TS.v)
                TS.calculateComponents;
            end
            
            v = TS.v;
        end
        
        function p = percentLessThan(TS, testValue)
            % Returns the percentage of the currents which are slower than
            % the passed in speed.
            
            p = RCM.Utils.iquantile(TS.Speed, testValue);
        end
        
        function ms = get.MeanSpeed(TS)
            if isempty(TS.MeanSpeed) || isnan(TS.MeanSpeed)
                TS.MeanSpeed = mean(TS.Speed);
            end
            
            ms = TS.MeanSpeed;
        end
        
        function ma = get.MajorAxis(TS)
            if isempty(TS.MajorAxis) || isnan(TS.MajorAxis)
                % Need covariance for major axis:
                PCAParameters = RCM.Utils.PCA(TS.u, TS.v);

                f = PCAParameters.eigenVector(1,PCAParameters.cols(1));
                g = PCAParameters.eigenVector(2,PCAParameters.cols(1));

                TS.MajorAxis = atan2(f,g);

                if mean(TS.v)<0
                    TS.MajorAxis = TS.MajorAxis + pi;
                end

                TS.MajorAxis = TS.MajorAxis * 180 / pi;      % convert to degrees
                TS.MajorAxis = mod(TS.MajorAxis + 360, 360); % make sure axis is between 0 and 360
            end
            
            ma = TS.MajorAxis;
        end
        
        function pc = get.ParallelComponent(TS)
            if isempty(TS.ParallelComponent) | isnan(TS.ParallelComponent)
                TS.ParallelComponent = TS.Speed.*cosd(TS.Direction - TS.MajorAxis);
            end
            
            pc = TS.ParallelComponent;
        end
        
        function nc = get.NormalComponent(TS)
            if isempty(TS.NormalComponent) | isnan(TS.NormalComponent)
                TS.NormalComponent = TS.Speed.*sind(TS.Direction - TS.MajorAxis);
            end
            
            nc = TS.NormalComponent;
        end
        
        function pa = get.ParallelAmplitude(TS)
            if isempty(TS.ParallelAmplitude) || isnan(TS.ParallelAmplitude)
                % sqrt(2) converts RMS into amplitude
                TS.ParallelAmplitude = sqrt(2) * std(TS.ParallelComponent, 1);
            end
            
            pa = TS.ParallelAmplitude;
        end
        
        function na = get.NormalAmplitude(TS)
            if isempty(TS.NormalAmplitude) || isnan(TS.NormalAmplitude)
                % sqrt(2) converts RMS into amplitude
                TS.NormalAmplitude = sqrt(2) * std(TS.NormalComponent, 1);
            end
            
            na = TS.NormalAmplitude;
        end
        
        function aa = get.AmplitudeAnisotropy(TS)
            if isempty(TS.AmplitudeAnisotropy) || isnan(TS.AmplitudeAnisotropy)
                TS.AmplitudeAnisotropy = TS.ParallelAmplitude / TS.NormalAmplitude;
            end
            
            aa = TS.AmplitudeAnisotropy;
        end
        
        function rs = get.ResidualSpeed(TS)
            if isempty(TS.ResidualSpeed) || isnan(TS.ResidualSpeed)
                TS.ResidualSpeed = sqrt(sum(TS.u)^2+sum(TS.v)^2)/TS.length;
            end
            
            rs = TS.ResidualSpeed;
        end
        
        function rd = get.ResidualDirection(TS)
            if isempty(TS.ResidualDirection) || isnan(TS.ResidualDirection)
                rd = acosd(mean(TS.v)/TS.ResidualSpeed);

                if mean(TS.u) < 0
                    rd = 360 - rd;
                end

                TS.ResidualDirection = rd;
            end
            
            rd = TS.ResidualDirection;
        end
        
        function rcma = get.ResidualConsistentMajorAxis(TS)
            % The major axis really points in two diametrically opposite
            % directions. This function returns the direction which is
            % closest to the residual current direction
            
            if isempty(TS.ResidualConsistentMajorAxis) || isnan(TS.ResidualConsistentMajorAxis)
                absDiff = abs(TS.MajorAxis - TS.ResidualDirection);

                if absDiff > 90 && absDiff < 270
                    if TS.MajorAxis > TS.ResidualDirection
                        TS.ResidualConsistentMajorAxis = TS.MajorAxis-180;
                    else
                        TS.ResidualConsistentMajorAxis = TS.MajorAxis+180;
                    end
                else
                    TS.ResidualConsistentMajorAxis = TS.MajorAxis;
                end
            end
            
            rcma = TS.ResidualConsistentMajorAxis;                
        end
        
        function rmaa = get.ResidualMajorAxisAngle(TS)
            % Returns the angle between the major axis and the residual
            % current
            
            if isempty(TS.ResidualMajorAxisAngle) || isnan(TS.ResidualMajorAxisAngle)
                TS.ResidualMajorAxisAngle = abs(TS.ResidualConsistentMajorAxis - TS.ResidualDirection);
             
                if TS.ResidualMajorAxisAngle > 270
                    TS.ResidualMajorAxisAngle = 360 - TS.ResidualMajorAxisAngle;
                end
            end
            
            rmaa = TS.ResidualMajorAxisAngle;
        end
        
        function wl = waterLevels(TS)
            if ~isempty(TS.Pressure)
                normalisedPressure = TS.Pressure - mean(TS.Pressure);
                
                wl = RCM.WaterLevel.TimeSeries.create(TS.Time, normalisedPressure);
                
                wl.Easting   = TS.Easting;
                wl.Northing  = TS.Northing;
                wl.Latitude  = TS.Latitude;
                wl.Longitude = TS.Longitude;
            else
                error('RCM:Current:TimeSeries:InsufficientData', ...
                    'Pressure property is empty: cannot instantiate water level object.')
            end
        end
                
        function TS = calculateHarmonics(TS)
            % Generates a harmonic analysis for the current data and
            % populates the appropriate instance properties (.tideCoefficients,
            % .uTidal, .vTidal, etc.)
            
            if isnan(TS.Latitude)
                fprintf('Latitude not known. Cannot perform harmonic analysis\n')
                return
            end
            
            try
                cmd = sprintf('tideCoefficients=ut_solv(TS.Time, TS.u, TS.v,%f, ''auto'', ''ols'', ''white'', ''LinCI'')', TS.Latitude);
                evalc(cmd); % Calling function this way suppresses text output
            catch
                fprintf('OH DEAR, tide stuff failed\n')
                tideCoefficients=[];
            end
            
            if ~isempty(tideCoefficients)
                [ut,vt] = ut_reconstr(TS.Time, tideCoefficients);
                du = TS.u - ut;
                dv = TS.v - vt;
                
                [TS.SpeedTidal,TS.DirectionTidal] = RCM.Utils.uv2spd(ut,vt);
            
                TS.Tideyness = mean(TS.Speed - TS.SpeedTidal)/mean(TS.Speed);
            else
                ut = [];
                vt = [];
                du = [];
                dv = [];
            end
            
            TS.TideCoefficients=tideCoefficients;
            TS.uTidal=ut;
            TS.vTidal=vt;
            TS.uNonTidal=du;
            TS.vNonTidal=dv;
        end
                
        function [cumVec] = cumulativeVector(TS)
            % Returns cumulative vector for the entire record.
            %
            % This vector represents individual u and v components
            % multiplied by the sampling time interval and therefore
            % represents a cumulative *position* vector.
                       
            timeInterval = TS.timeIntervalSeconds;
            
            cumVec      = zeros(length(TS.u)-1, 2);
            cumVec(1,1) = TS.u(1) * timeInterval;
            cumVec(1,2) = TS.v(1) * timeInterval;
            
            for i = 2:length(TS.u)
                cumVec(i,1) = TS.u(i) * timeInterval + cumVec(i-1,1);
                cumVec(i,2) = TS.v(i) * timeInterval + cumVec(i-1,2);
            end
        end  
            
        function tps = tidalPhaseStat(TS, property, func)
            wl = TS.waterLevels;
            slackIndexes = wl.slackIndexes;
            
            % Initialize vector to store the mean value for each flood and ebb tide
            tps = zeros(size(slackIndexes,1)+1,1);

            tps(1) = eval([func,'(TS.(property)(1:slackIndexes(1)))']);
            
            for i = 1:size(slackIndexes,1)-1
                tps(i+1) = eval([func,'(TS.(property)(slackIndexes(i):slackIndexes(i+1)))']);
            end
            
            tps(end) = eval([func,'(TS.(property)(slackIndexes(end):end))']);
        end      
        
        function tpm = tidalPhaseMean(TS, property)
            tpm = tidalPhaseStat(TS, property, 'mean');
        end
        
        function tpm = tidalPhaseMax(TS, property)
            tpm = tidalPhaseStat(TS, property, 'max');
        end
        
        function tpm = tidalPhaseMin(TS, property)
            tpm = tidalPhaseStat(TS, property, 'min');
        end
        
        function tpm = tidalPhaseStd(TS, property)
            tpm = tidalPhaseStat(TS, property, 'std');
        end
        
        function [fit1, rSq1, fit2, rSq2] = fitMeanSpeed2TidalRange(TS, varargin)
            [fit1, rSq1, fit2, rSq2] = RCM.Current.TimeSeries.fitProperty2TidalRange(TS, TS.waterLevels, varargin{:})
        end
        
        function scaledTS = extendAndScale(TS, days, varargin)
        end
        
        function scaledTS = scale(TS, queryStartTime, days, varargin)
            % Here's the logic for scaling.
            %
            %
            
            generatePlot      = 0;
            randomizeNonTidal = 0;
            scaleUniformly    = 0;
            
            if ~isempty(varargin)
                for i = 1:2:size(varargin,2) % only bother with odd arguments, i.e. the labels
                    switch varargin{i}
                      case 'plot'
                          generatePlot = varargin{i+1};
                      case 'randomizeNonTidal'
                          randomizeNonTidal = varargin{i+1};
                      case 'scaleUniformly'
                          scaleUniformly = varargin{i+1};
                    end
                end   
            end
                        
            [uFitFlood, vFitFlood, uFitEbb, vFitEbb] = RCM.Current.TimeSeries.fitTidalComponents2WaterLevelChange(TS, TS.waterLevels, varargin{:})
            
            if isempty(TS.TotalTidePort)
                TS.getTotalTidePort();
            end            
            
            % Get heights from Total Tide for the period under consideration. 
            % Get records for both a day before and a day after the required 
            % time period. This ensures that we get slack water levels before 
            % and after the time period and therefore can calculate tidal 
            % phase ranges for every datapoint
            ttWaterLevel = RCM.WaterLevel.TimeSeries.fromTotalTide( ...
                queryStartTime-1, days + 2, ...
                'resolution', TS.timeIntervalSeconds/60, 'port', TS.TotalTidePort);
            
            % The Total Tide record starts at midnight the day prior to our
            % required time interval, so lets truncate it to start at the same time 
            % as our time series (well, the closest record).
            ttWaterLevel.truncateByTime('startTime', queryStartTime);
            
            % The Total Tide record spans a day longer than we need. Truncate 
            % to the total number of days required.
            ttWaterLevel.truncateToDays(days);
            
            % Normalise the data to a mean of zero. This is not really
            % required as it doesnt affect the range between slack levels
            % but it is good practice.
            ttWaterLevel.normalise;
            
            % Get the total tide water levels for the period representing
            % the sampled data. This will provide a reference point against
            % which to measure the size of tide variations.
            refWaterLevel = RCM.WaterLevel.TimeSeries.fromTotalTide( ...
                TS.startTime-1, TS.lengthDays + 2, ...
                'resolution', TS.timeIntervalSeconds/60, 'port', TS.TotalTidePort);
            
            % Truncate to same start time as sampled data
            refWaterLevel.truncateByTime('startTime', TS.startTime);
            
            % Shift the water level data to the query start time point
            refWaterLevel.shiftInTime(queryStartTime);
                        
            % Repeat the water levels in the first spring-neap cycle
            % through the required time period.
            refWaterLevel.repeatSpringNeapCycle(days);
            
            % normalise to zero
            refWaterLevel.normalise;
            
            % find the inflection points in the spring-neap cycles for both
            % water level records. This will belp match up spring neap
            % periods
            ttInflectionIdxs  = find(ttWaterLevel.isSpringNeapInflection);
            refInflectionIdxs = find(refWaterLevel.isSpringNeapInflection);
            
            % We only want every *other* inflection point, since there are
            % two inflection points in each spring-neap cycle and we want
            % to identify *whole* spring-neap cycles. Filter out every
            % other index.
            ttInflectionIdxs = ttInflectionIdxs(1:2:length(ttInflectionIdxs));
            refInflectionIdxs = refInflectionIdxs(1:2:length(refInflectionIdxs));
            
            % find the number of spring-neap cycles. Use min, just in case
            % there is a discrepancy of 1 cycle. There shouldn't be!
            numberOfSpringNeapCycles = min([length(ttInflectionIdxs) length(refInflectionIdxs)]);
            
            % We'll calculate the standard deviation of tidal ranges for
            % each spring-neap cycle. This will form the basis of the
            % comparison between the "real" tidal record and the repeated,
            % reference one.
            %
            % Initialize some vectors for these.
            ttSpringNeapStds = ones(numberOfSpringNeapCycles,1);
            refSpringNeapStds = ones(numberOfSpringNeapCycles,1);
            
            % If there is insufficient data at the start of either records to
            % get a erasonable standard deviation for the tidal ranges then
            % just set both to unity, then their scaling factor will also
            % just be unity. This avoids very small standard deviations
            % being calculated from a few very similar semi-diurnal tides
            % and causing the scaling factor to become reasonably large.
            %
            % We'll expect atleast half a spring-neap cycle to get a good
            % scaling factor.
            if ttInflectionIdxs(1) < ttWaterLevel.dataPointsPerSpringNeapCycle/2 || ...
                    refInflectionIdxs(1) < refWaterLevel.dataPointsPerSpringNeapCycle/2
                
                ttSpringNeapStds(1)  = 1;
                refSpringNeapStds(1) = 1;
            else
                ttSpringNeapStds(1)  = max(abs(ttWaterLevel.TidalRange(1:ttInflectionIdxs(1)-1)));
                refSpringNeapStds(1) = max(abs(refWaterLevel.TidalRange(1:refInflectionIdxs(1)-1)));
            end
            
            for snc = 1:numberOfSpringNeapCycles-1
                ttSpringNeapStds(snc+1)  = max(abs(ttWaterLevel.TidalRange(ttInflectionIdxs(snc):ttInflectionIdxs(snc+1)-1)));
                refSpringNeapStds(snc+1) = max(abs(refWaterLevel.TidalRange(refInflectionIdxs(snc):refInflectionIdxs(snc+1)-1)));
            end
            
            % As above - set scaling factor to unity if there is
            % insufficient data at the end of either record.
            if (ttWaterLevel.length - ttInflectionIdxs(numberOfSpringNeapCycles)) < ttWaterLevel.dataPointsPerSpringNeapCycle || ...
                   (refWaterLevel.length - refInflectionIdxs(numberOfSpringNeapCycles)) < refWaterLevel.dataPointsPerSpringNeapCycle
                 
                ttSpringNeapStds(numberOfSpringNeapCycles)  = 1;
                refSpringNeapStds(numberOfSpringNeapCycles) = 1;
            else
                ttSpringNeapStds(numberOfSpringNeapCycles)  = max(abs(ttWaterLevel.TidalRange(ttInflectionIdxs(end):end)));
                refSpringNeapStds(numberOfSpringNeapCycles) = max(abs(refWaterLevel.TidalRange(refInflectionIdxs(end):end)));
            end
              
            % Calculate spring-neap size difference factors by taking ratio of 
            % the spring-neap tidal range standard deviations for "real" and 
            % reference water levels
            rangeRatios = ttSpringNeapStds./refSpringNeapStds;
            
            % Map the size difference factors to each data point
            rangeRatiosPerTimeStep = ones(refWaterLevel.length,1);
            
            rangeRatiosPerTimeStep(1:refInflectionIdxs(1)-1,1) = rangeRatios(1);

            for i = 1:numberOfSpringNeapCycles-1
               rangeRatiosPerTimeStep(refInflectionIdxs(i):refInflectionIdxs(i+1)-1,1) = rangeRatios(i+1);
            end
            
            rangeRatiosPerTimeStep(refInflectionIdxs(end):end,1) = rangeRatios(end);
  
            scaledTS = TS.clone;
            scaledTS.shiftInTime(queryStartTime);
            scaledTS.repeatSpringNeapCycle(days);
                    
            scaledTS.waterLevels.normalise;
            
            if scaleUniformly
                scalingFactor = rangeRatiosPerTimeStep;
            else
                scalingFactor = rangeRatiosPerTimeStep.^refWaterLevel.springNeapPhase;
            end        
            
            UFlood = scalingFactor.*scaledTS.uTidal + (1-scalingFactor).*uFitFlood(2);
            VFlood = scalingFactor.*scaledTS.vTidal + (1-scalingFactor).*vFitFlood(2);
            UEbb   = scalingFactor.*scaledTS.uTidal + (1-scalingFactor).*uFitEbb(2);
            VEbb   = scalingFactor.*scaledTS.vTidal + (1-scalingFactor).*vFitEbb(2);

            scaledTS.uTidal = UFlood;
            scaledTS.vTidal = VFlood;
            
            ebbIdxs = ttWaterLevel.gradient < 0;
            
            scaledTS.uTidal(ebbIdxs) = UEbb(ebbIdxs);
            scaledTS.vTidal(ebbIdxs) = VEbb(ebbIdxs) ;
            
            [scaledTS.SpeedTidal, scaledTS.DirectionTidal] = RCM.Utils.uv2spd(scaledTS.uTidal,scaledTS.vTidal);
            
            if randomizeNonTidal
                scaledTS.uNonTidal = scaledTS.uNonTidal(randperm(size(scaledTS.uNonTidal,1)), :);
                scaledTS.vNonTidal = scaledTS.vNonTidal(randperm(size(scaledTS.vNonTidal,1)), :);
            end
            
            scaledTS.u = scaledTS.uTidal + scaledTS.uNonTidal;
            scaledTS.v = scaledTS.vTidal + scaledTS.vNonTidal;
            
            [scaledTS.Speed, scaledTS.Direction] = RCM.Utils.uv2spd(scaledTS.u,scaledTS.v); 
            
            meanPressure = mean(scaledTS.Pressure);
            % This may be out of phase. Maybe do a scaled up pressure
            % record.
            scaledTS.Pressure = ttWaterLevel.Height + meanPressure;
            scaledTS.clearDerivedProperties;
            
            if generatePlot
                figure;
                subplot(511);
                plot(abs(ttWaterLevel.TidalRange), 'b');
                grid on;
                hold on
                
                plot(abs(refWaterLevel.TidalRange), 'r');
                
                plot(rangeRatiosPerTimeStep, 'g', 'LineWidth', 3);
                
                subplot(512);
                plot(refWaterLevel.springNeapPhase, 'k', 'LineWidth', 3);
                grid on;
                hold on;
                
                plot(scalingFactor, 'k', 'LineWidth', 3);
                
                subplot(513);
                plot(scaledTS.SpeedTidal, 'k--');
                grid on;
                
                [SpeedNonTidal,~] = RCM.Utils.uv2spd(scaledTS.uNonTidal, scaledTS.vNonTidal);
                
                subplot(514);
                plot(SpeedNonTidal, 'k--');
                grid on;
                
                subplot(515);
                plot(scaledTS.Speed, 'k--');
                grid on;
            end
        end

         
        function [str] = toStruct(TS)
            % Returns a struct representation of the object.
            
            str = struct(TS);
        end
        
        function [str] = toArchiveStruct(TS)
            % Returns a struct representation of the object with the names
            % of some fields changed to be consistent with OceanMet archive
            % conventions
            
            str = TS.toStruct;
            
            aliases = {...
                'Time',      'timeGmt';...
                'Speed',     'speed';...
                'Direction', 'directionMagnetic';...
                'u',         'velocityU';...
                'v',         'velocityV';
                'Pressure',  'pressureDepth'...
                };
            
            for i = 1:size(aliases,1)
                str.(aliases{i,2}) = str.(aliases{i,1});
                str = rmfield(str, aliases{i,1});
            end            
        end
        
    end
    
    methods (Access = protected)
        
        function calculateComponents(TS)
            [TS.u, TS.v] = RCM.Utils.spd2uv(TS.Speed, TS.Direction);
        end
        
        function calculateSpeed(TS)
            [TS.Speed,TS.Direction] = RCM.Utils.uv2spd(TS.u,TS.v); 
        end
    end
    
end

