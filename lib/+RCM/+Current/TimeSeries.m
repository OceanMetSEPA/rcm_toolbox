classdef TimeSeries < RCM.TimeSeries.TotalTide ... % Abstract classes first
        & RCM.Current.TimeSeries.Plotter ...
        & RCM.TimeSeries.Base
    
    % Class for representing and manipulating current timeseries data.
    % Instances are created by passing in three vectors representing 
    %
    %   - time
    %   - speed
    %   - direction
    %
    % The current vectors are decomposed into their constituent u and v
    % components, and stored on the .u and .v properties. A number of descriptive 
    % statistics and a harmonic analysis of the data can be easily done.
    % There are useful methods for generating plots and contextualising
    % the data using Total Tide.
    %
    % Object properties are also available for storing other commonly
    % useful data such as a corresponding presure record (.Pressure), the RCM easting 
    % (.Easting) and northing (.Northing), and the height above the sea bed
    % of the respective RCM bin (.HeightAboveBed). The class extends
    % *dynamicprops* and therefore any other properties can be added
    % arbitrarily when needed.
    %
    % Usage:
    %
    %    C = RCM.Current.TimeSeries(time, speed, direction);
    %
    % where dateTime, speed, direction are vectors describing the time (as
    %       datenums), speed and direction of currents
    % 
    %
    % EXAMPLES:
    %
    %   currents = RCM.Current.TimeSeries(timeVector, speedVector, directionVector)
    %   currents.Time
    %     ans =
    %               735168.477083333
    %               735168.490972222
    %               735168.504861111
    %               ...
    %
    %   currents.Speed
    %     ans =
    %               0.0467
    %               0.1099
    %               0.0548
    %               ...
    %
    %   currents.Direction
    %     ans =
    %               212.75
    %               171.83
    %               108.27
    %               ...
    %  
    %   currents.u
    %     ans =
    %            -0.0252635078128853
    %             0.0156179624742282
    %             0.0520375184947972
    %             ...
    %
    %   currents.v
    %     ans =
    %            -0.0392765219054371
    %             -0.108784600234379
    %            -0.0171795421622242
    %             ...
    %
    %      
    %  ## Statistics ##
    %
    %  Summary statistics are generated which can be accessed via the following fields
    %
    %   currents.MeanSpeed
    %   currents.MajorAxis
    %   currents.ParallelAmplitude
    %   currents.NormalAmplitude
    %   currents.AmplitudeAnisotropy
    %   currents.ResidualSpeed
    %   currents.ResidualDirection
    %
    %  Some other derivations from the data can be accessed using these
    %  methods:
    %
    %   currents.percentLessThan()
    %   currents.normalisedComponents()
    %   currents.cumulativeVector()
    %
    %  ## Harmonics ##
    %
    %  A harmonic analysis can be generated by running the following
    %  method
    %
    %   currents.calculateHarmonics() 
    %   
    %  and the results can be accessed via the following fields
    %
    %   currents.TideCoefficients
    %   currents.TideReconstructedComponents
    %   currents.uTidal
    %   currents.vTidal
    %   currents.uNonTidal
    %   currents.vNonTidal
    %   currents.SpeedTidal
    %   currents.DirectionTidal
    %   currents.Tideyness
    %
    %  NOTE: harmonic analysis requires a latitude, which needs to be set
    %  using either the .Latitude property explicity or by setting the 
    %  .Easting and .Northing properties.
    %
    %  ## Plots ##
    %
    %  A number of standard plots can be easily generated using the
    %  following methods
    %   
    %   currents.scatterPlot
    %   currents.normalisedScatterPlot
    %   currents.cumulativeVectorPlot
    %
    %
    % DEPENDENCIES:
    %
    % - UTide
    % - +TotalTide/
    % - +RCM/+Utils
    % - OS.catCoordinates.m
    % - greatCircleDistance.m
    %
    
    properties (SetAccess = public, GetAccess = public)  
        % required for instantiation
        Speed@double     = [];
        Direction@double = [];
        
        % optional
        Pressure@double = [];
        HeightAboveBed = NaN;
        
        % Components - derived
        u@double = [];
        v@double = [];
        ParallelComponent@double = [];
        NormalComponent@double   = [];
        
        % Stats - derived
        MeanSpeed@double            = NaN;
        MajorAxis@double            = NaN;
        ParallelAmplitude@double    = NaN;
        NormalAmplitude@double      = NaN;
        AmplitudeAnisotropy@double  = NaN;
        ResidualSpeed@double        = NaN;
        ResidualDirection@double    = NaN;
        
        ResidualConsistentMajorAxis@double = NaN;
        ResidualMajorAxisAngle@double      = NaN;
        
        % Tide - derived
        TideCoefficients = [];
        uTidal@double          = [];
        vTidal@double          = [];
        uNonTidal@double       = [];
        vNonTidal@double       = [];
        SpeedTidal@double      = [];
        DirectionTidal@double  = [];
        Tideyness@double       = NaN;
    end
    
    methods(Static = true)
        
        function TS = create(time, speed, direction)
            TS = RCM.Current.TimeSeries;
            
            TS.Time      = time;
            TS.Speed     = speed;
            TS.Direction = direction;
            
            TS.calculateComponents;
        end
        
        function TS = createFromComponents(time, u, v)
            TS = RCM.Current.TimeSeries;
            
            TS.Time = time;
            TS.u    = u;
            TS.v    = v;
            
            TS.calculateSpeed;
        end
        
        function ts = fromStruct(s)
            ts = RCM.Current.TimeSeries.create(s.Time, s.Speed,s.Direction);

            ts.Pressure       = s.Pressure;
            ts.Easting        = s.Easting;
            ts.Northing       = s.Northing;
            ts.HeightAboveBed = s.HeightAboveBed;
        end
           
    end
    
    methods
        
        function u = get.u(TS)
            if isempty(TS.u) | isnan(TS.u)
                TS.calculateComponents;
            end
            
            u = TS.u;
        end
        
        function v = get.v(TS)
            if isempty(TS.v) | isnan(TS.v)
                TS.calculateComponents;
            end
            
            v = TS.v;
        end
        
        function p = percentLessThan(TS, testValue)
            % Returns the percentage of the currents which are slower than
            % the passed in speed.
            
            p = RCM.Utils.iquantile(TS.Speed, testValue);
        end
        
        function ms = get.MeanSpeed(TS)
            if isempty(TS.MeanSpeed) || isnan(TS.MeanSpeed)
                TS.MeanSpeed = mean(TS.Speed);
            end
            
            ms = TS.MeanSpeed;
        end
        
        function ma = get.MajorAxis(TS)
            if isempty(TS.MajorAxis) || isnan(TS.MajorAxis)
                % Need covariance for major axis:
                PCAParameters = RCM.Utils.PCA(TS.u, TS.v);

                f = PCAParameters.eigenVector(1,PCAParameters.cols(1));
                g = PCAParameters.eigenVector(2,PCAParameters.cols(1));

                TS.MajorAxis = atan2(f,g);

                if mean(TS.v)<0
                    TS.MajorAxis = TS.MajorAxis + pi;
                end

                TS.MajorAxis = TS.MajorAxis * 180 / pi;      % convert to degrees
                TS.MajorAxis = mod(TS.MajorAxis + 360, 360); % make sure axis is between 0 and 360
            end
            
            ma = TS.MajorAxis;
        end
        
        function pc = get.ParallelComponent(TS)
            if isempty(TS.ParallelComponent) | isnan(TS.ParallelComponent)
                TS.ParallelComponent = TS.Speed.*cosd(TS.Direction - TS.MajorAxis);
            end
            
            pc = TS.ParallelComponent;
        end
        
        function nc = get.NormalComponent(TS)
            if isempty(TS.NormalComponent) | isnan(TS.NormalComponent)
                TS.NormalComponent = TS.Speed.*sind(TS.Direction - TS.MajorAxis);
            end
            
            nc = TS.NormalComponent;
        end
        
        function pa = get.ParallelAmplitude(TS)
            if isempty(TS.ParallelAmplitude) || isnan(TS.ParallelAmplitude)
                % sqrt(2) converts RMS into amplitude
                TS.ParallelAmplitude = sqrt(2) * std(TS.ParallelComponent, 1);
            end
            
            pa = TS.ParallelAmplitude;
        end
        
        function na = get.NormalAmplitude(TS)
            if isempty(TS.NormalAmplitude) || isnan(TS.NormalAmplitude)
                % sqrt(2) converts RMS into amplitude
                TS.NormalAmplitude = sqrt(2) * std(TS.NormalComponent, 1);
            end
            
            na = TS.NormalAmplitude;
        end
        
        function aa = get.AmplitudeAnisotropy(TS)
            if isempty(TS.AmplitudeAnisotropy) || isnan(TS.AmplitudeAnisotropy)
                TS.AmplitudeAnisotropy = TS.ParallelAmplitude / TS.NormalAmplitude;
            end
            
            aa = TS.AmplitudeAnisotropy;
        end
        
        function rs = get.ResidualSpeed(TS)
            if isempty(TS.ResidualSpeed) || isnan(TS.ResidualSpeed)
                TS.ResidualSpeed = sqrt(sum(TS.u)^2+sum(TS.v)^2)/TS.length;
            end
            
            rs = TS.ResidualSpeed;
        end
        
        function rd = get.ResidualDirection(TS)
            if isempty(TS.ResidualDirection) || isnan(TS.ResidualDirection)
                rd = acosd(mean(TS.v)/TS.ResidualSpeed);

                if mean(TS.u) < 0
                    rd = 360 - rd;
                end

                TS.ResidualDirection = rd;
            end
            
            rd = TS.ResidualDirection;
        end
        
        function rcma = get.ResidualConsistentMajorAxis(TS)
            % The major axis really points in two diametrically opposite
            % directions. This function returns the direction which is
            % closest to the residual current direction
            
            if isempty(TS.ResidualConsistentMajorAxis) || isnan(TS.ResidualConsistentMajorAxis)
                absDiff = abs(TS.MajorAxis - TS.ResidualDirection);

                if absDiff > 90 && absDiff < 270
                    if TS.MajorAxis > TS.ResidualDirection
                        TS.ResidualConsistentMajorAxis = TS.MajorAxis-180;
                    else
                        TS.ResidualConsistentMajorAxis = TS.MajorAxis+180;
                    end
                else
                    TS.ResidualConsistentMajorAxis = TS.MajorAxis;
                end
            end
            
            rcma = TS.ResidualConsistentMajorAxis;                
        end
        
        function rmaa = get.ResidualMajorAxisAngle(TS)
            % Returns the angle between the major axis and the residual
            % current
            
            if isempty(TS.ResidualMajorAxisAngle) || isnan(TS.ResidualMajorAxisAngle)
                TS.ResidualMajorAxisAngle = abs(TS.ResidualConsistentMajorAxis - TS.ResidualDirection);
             
                if TS.ResidualMajorAxisAngle > 270
                    TS.ResidualMajorAxisAngle = 360 - TS.ResidualMajorAxisAngle;
                end
            end
            
            rmaa = TS.ResidualMajorAxisAngle;
        end
        
        function wl = waterLevels(TS)
            if ~isempty(TS.Pressure)
                normalisedPressure = TS.Pressure - mean(TS.Pressure);
                
                wl = RCM.WaterLevel.TimeSeries.create(TS.Time, normalisedPressure);
                
                wl.Easting   = TS.Easting;
                wl.Northing  = TS.Northing;
                wl.Latitude  = TS.Latitude;
                wl.Longitude = TS.Longitude;
            else
                error('RCM:Current:TimeSeries:InsufficientData', ...
                    'Pressure property is empty: cannot instantiate water level object.')
            end
        end
                
        function TS = calculateHarmonics(TS)
            % Generates a harmonic analysis for the current data and
            % populates the appropriate instance properties (.tideCoefficients,
            % .uTidal, .vTidal, etc.)
            
            if isnan(TS.Latitude)
                fprintf('Latitude not known. Cannot perform harmonic analysis\n')
                return
            end
            
            try
                cmd = sprintf('tideCoefficients=ut_solv(TS.Time, TS.u, TS.v,%f, ''auto'', ''ols'', ''white'', ''LinCI'')', TS.Latitude);
                evalc(cmd); % Calling function this way suppresses text output
            catch
                fprintf('OH DEAR, tide stuff failed\n')
                tideCoefficients=[];
            end
            
            if ~isempty(tideCoefficients)
                [ut,vt] = ut_reconstr(TS.Time, tideCoefficients);
                du = TS.u - ut;
                dv = TS.v - vt;
                
                [TS.SpeedTidal,TS.DirectionTidal] = RCM.Utils.uv2spd(ut,vt);
            
                TS.Tideyness = mean(TS.Speed - TS.SpeedTidal)/mean(TS.Speed);
            else
                ut = [];
                vt = [];
                du = [];
                dv = [];
            end
            
            TS.TideCoefficients=tideCoefficients;
            TS.uTidal=ut;
            TS.vTidal=vt;
            TS.uNonTidal=du;
            TS.vNonTidal=dv;
        end
                
        function [cumVec] = cumulativeVector(TS)
            % Returns cumulative vector for the entire record.
            %
            % This vector represents individual u and v components
            % multiplied by the sampling time interval and therefore
            % represents a cumulative *position* vector.
                       
            timeInterval = TS.timeIntervalSeconds;
            
            cumVec      = zeros(length(TS.u)-1, 2);
            cumVec(1,1) = TS.u(1) * timeInterval;
            cumVec(1,2) = TS.v(1) * timeInterval;
            
            for i = 2:length(TS.u)
                cumVec(i,1) = TS.u(i) * timeInterval + cumVec(i-1,1);
                cumVec(i,2) = TS.v(i) * timeInterval + cumVec(i-1,2);
            end
        end  
            
        function tps = tidalPhaseStat(TS, property, func)
            wl = TS.waterLevels;
            slackIndexes = wl.slackIndexes;
            
            % Initialize vector to store the mean value for each flood and ebb tide
            tps = zeros(size(slackIndexes,1)+1,1);

            tps(1) = eval([func,'(TS.(property)(1:slackIndexes(1)))']);
            
            for i = 1:size(slackIndexes,1)-1
                tps(i+1) = eval([func,'(TS.(property)(slackIndexes(i):slackIndexes(i+1)))']);
            end
            
            tps(end) = eval([func,'(TS.(property)(slackIndexes(end):end))']);
        end      
        
        function tpm = tidalPhaseMean(TS, property)
            tpm = tidalPhaseStat(TS, property, 'mean');
        end
        
        function tpm = tidalPhaseMax(TS, property)
            tpm = tidalPhaseStat(TS, property, 'max');
        end
        
        function tpm = tidalPhaseMin(TS, property)
            tpm = tidalPhaseStat(TS, property, 'min');
        end
        
        function tpm = tidalPhaseStd(TS, property)
            tpm = tidalPhaseStat(TS, property, 'std');
        end
        
        function [fit1, rSq1, fit2, rSq2] = fitMeanSpeed2TidalRange(TS, varargin)
            [fit1, rSq1, fit2, rSq2] = RCM.Current.TimeSeries.fitProperty2TidalRange(TS, TS.waterLevels, varargin{:})
        end
        
%         function scaledTS = extendAndScale(TS, days, varargin)
%             % Here's the logic for scaling.
%             %
%             % We use the sampled speed and pressure records to derive an
%             % emprical, linear relationship between the tidal range in 
%             % each flood/ebb phase and the mean speed experienced. We then
%             % use this relationship, together with water levels obtained 
%             % from Total Tide, to scale the current speeds through the 
%             % extended time period.
%             % 
%             % To do this we truncate the sampled data to a single spring-neap 
%             % cycle length so that it can be repeated through the extended
%             % time period. We also repeat the water levels (from Total
%             % Tide) for the sampling period through the extended time
%             % period to provide a baseline against which the longer term
%             % variations in water level can be measured. For each flood and
%             % ebb phase in both the repeated and varying water level time 
%             % series, we can now calculate the mean current speed based on
%             % the empirical relationship established above. Then, for each
%             % flood and ebb phase we can calculate a scaling factor by
%             % dividing the mean current speed in the longer term (varying)
%             % data set by the mean current speed in the repeated data set.
%             % We then apply these scaling factors to the repeated speed 
%             % records.
%             
%             generatePlot = 0;            
%             tidalOnly    = 0;
%             splitPhases  = 0;
%             
%             if ~isempty(varargin)
%                 for i = 1:2:size(varargin,2) % only bother with odd arguments, i.e. the labels
%                     switch varargin{i}
%                       case 'plot'
%                         generatePlot = varargin{i + 1};
%                       case 'tidalOnly'
%                         tidalOnly = varargin{i + 1};
%                       case 'splitPhases'
%                         splitPhases = varargin{i + 1};
%                     end
%                 end   
%             end
%             
%             
%             % Need to add support for tidal only and split phases
%             
%             % Get speed-range relationship
%             if splitPhases
%                 [fit1, rSq1, fit2, rSq2] = TS.fitMeanSpeed2TidalRange('metric', 'max', varargin{:});
%             else
%                 [fit, rSq] = TS.fitMeanSpeed2TidalRange('metric', 'max', varargin{:});
%             end
%             
%             if isempty(TS.TotalTidePort)
%                 TS.getTotalTidePort();
%             end
%             
%             % Get heights from Total Tide for the period under consideration. 
%             % Get records for both a day before and a day after the required 
%             % time period. This ensures that we get slack water levels before 
%             % and after the time period and therefore can calculate tidal 
%             % phase ranges for every datapoint
%             ttHeights = TotalTide.getStationHeights(TS.TotalTidePort, ...
%                 datestr(TS.startTime-1,'dd/mm/yyyy'), days + 2, TS.timeIntervalSeconds/60);
%             
%             % Convert Total Tide data to a WaterLevel object
%             ttWaterLevel = RCM.WaterLevel.TimeSeries.fromTotalTideStruct(ttHeights);
%             
%             % The Total Tide record starts at midnight the day prior to our
%             % required time interval, so lets truncate it to start at the same time 
%             % as our time series (well, the closest record).
%             ttWaterLevel.truncateByTime('startTime', TS.startTime);
%             
%             % The Total Tide record spans a day longer than we need. Now
%             % that we've set the tidal ranges, lets truncate to the total
%             % number of days required.
%             ttWaterLevel.truncateToDays(days);
%             
%             % Normalise the data to a mean of zero. This is not really
%             % required as it doesnt affect the range between slack levels
%             % but it is good practice.
%             ttWaterLevel.normalise;
% 
%             % Create another long term water level record but this time based on 
%             % the water levels during only the period covered by the current data
%             % repeated through the required longer term time period
%             
%             % Clone of the long term Total Tide water levels
%             refWaterLevel = ttWaterLevel.clone;
%                         
%             % Repeat the water levels in the first spring-neap cycle
%             % through the required time period.
%             refWaterLevel.repeatSpringNeapCycle(days);
%             
%             ttRanges = ttWaterLevel.ranges; 
%             refRanges = refWaterLevel.ranges;
%             noRanges = min(length(ttRanges), length(refRanges));
%             
%             % Now we have a long term water level record and a corresponding
%             % repeated water level record
%             if splitPhases
%                 ttMeanFloodSpeeds  = polyval(fit1,abs(ttRanges(1:noRanges)));
%                 refMeanFloodSpeeds = polyval(fit1,abs(refRanges(1:noRanges)));
%                 
%                 ttMeanEbbSpeeds  = polyval(fit2,abs(ttRanges(1:noRanges)));
%                 refMeanEbbSpeeds = polyval(fit2,abs(refRanges(1:noRanges)));
%                 
%                 floodScales = ttMeanFloodSpeeds./refMeanFloodSpeeds;
%                 ebbScales = ttMeanEbbSpeeds./refMeanEbbSpeeds;
%                 
%                 scales = floodScales;
%                 
%                 ebbIndexes = find(ttRanges < 0);
%                 scales(ebbIndexes) = ebbScales(ebbIndexes);   
%             else
%                 ttMeanSpeeds  = polyval(fit,abs(ttRanges(1:noRanges)));
%                 refMeanSpeeds = polyval(fit,abs(refRanges(1:noRanges)));
%                 
%                 scales = ttMeanSpeeds./refMeanSpeeds;
%             end
%             
%             scaledTS = TS.clone;
%             scaledTS.repeatSpringNeapCycle(days);
%             
%             speedProperty = 'Speed';
%             
%             if tidalOnly
%                 speedProperty = 'SpeedTidal';
%             end
% 
%             refSlackIndexes = refWaterLevel.slackIndexes;
%             
%             scaledTS.(speedProperty)(1:refSlackIndexes(1)-1,1) = scaledTS.(speedProperty)(1:refSlackIndexes(1)-1,1) * scales(1);
%             
%             for i = 1:length(refSlackIndexes)-1
%                scaledTS.(speedProperty)(refSlackIndexes(i):refSlackIndexes(i+1)-1,1) = ...
%                    scaledTS.(speedProperty)(refSlackIndexes(i):refSlackIndexes(i+1)-1,1) * scales(i);
%             end
%             
%             if tidalOnly
%                 [scaledTS.uTidal, scaledTS.vTidal] = RCM.Utils.spd2uv(scaledTS.SpeedTidal, scaledTS.DirectionTidal);  
%                 
%                 u_comp = scaledTS.uTidal + scaledTS.uNonTidal;
%                 v_comp = scaledTS.vTidal + scaledTS.vNonTidal;
%                 [scaledTS.Speed, scaledTS.Direction] = RCM.Utils.uv2spd(u_comp,v_comp);                
%             end
%             
%             meanPressure = mean(scaledTS.Pressure);
%             scaledTS.Pressure = ttWaterLevel.Height + meanPressure;
%             scaledTS.clearDerivedProperties;
%         end
      
        function scaledTS = extendAndScale(TS, days, varargin)
            % Here's the logic for scaling.
            %
            %
            
            generatePlot = 0;  
            
            if ~isempty(varargin)
                for i = 1:2:size(varargin,2) % only bother with odd arguments, i.e. the labels
                    switch varargin{i}
                      case 'plot'
                          generatePlot = varargin{i+1};
                    end
                end   
            end
                        
            [uFitFlood, vFitFlood, uFitEbb, vFitEbb] = RCM.Current.TimeSeries.fitTidalComponents2WaterLevelChange(TS, TS.waterLevels, varargin{:})
            
            if isempty(TS.TotalTidePort)
                TS.getTotalTidePort();
            end
            
            % Get heights from Total Tide for the period under consideration. 
            % Get records for both a day before and a day after the required 
            % time period. This ensures that we get slack water levels before 
            % and after the time period and therefore can calculate tidal 
            % phase ranges for every datapoint
            ttHeights = TotalTide.getStationHeights(TS.TotalTidePort, ...
                datestr(TS.startTime-1,'dd/mm/yyyy'), days + 2, TS.timeIntervalSeconds/60);
            
            % Convert Total Tide data to a WaterLevel object
            ttWaterLevel = RCM.WaterLevel.TimeSeries.fromTotalTideStruct(ttHeights);
            
            % The Total Tide record starts at midnight the day prior to our
            % required time interval, so lets truncate it to start at the same time 
            % as our time series (well, the closest record).
            ttWaterLevel.truncateByTime('startTime', TS.startTime);
            
            % The Total Tide record spans a day longer than we need. Now
            % that we've set the tidal ranges, lets truncate to the total
            % number of days required.
            ttWaterLevel.truncateToDays(days);
            
            % Normalise the data to a mean of zero. This is not really
            % required as it doesnt affect the range between slack levels
            % but it is good practice.
            ttWaterLevel.normalise;
            
            refWaterLevel = ttWaterLevel.clone;
                        
            % Repeat the water levels in the first spring-neap cycle
            % through the required time period.
            refWaterLevel.repeatSpringNeapCycle(days);
            
            ttRanges = ttWaterLevel.ranges; 
            refRanges = refWaterLevel.ranges;
            noRanges = min(length(ttRanges), length(refRanges));
            rangeRatios = ttRanges(1:noRanges)./refRanges(1:noRanges);
            
            rangeRatiosPerTimeStep = zeros(refWaterLevel.length,1);
            
            refSlackIndexes = find(refWaterLevel.isSlack);
            
            rangeRatiosPerTimeStep(1:refSlackIndexes(1)-1,1) = rangeRatios(1);
            
            for i = 1:length(refSlackIndexes)-1
               rangeRatiosPerTimeStep(refSlackIndexes(i):refSlackIndexes(i+1)-1,1) = rangeRatios(i);
            end
            
            scaledTS = TS.clone;
            scaledTS.repeatSpringNeapCycle(days);
            
            UFlood = rangeRatiosPerTimeStep.*scaledTS.uTidal + (1-rangeRatiosPerTimeStep).*uFitFlood(2);
            VFlood = rangeRatiosPerTimeStep.*scaledTS.vTidal + (1-rangeRatiosPerTimeStep).*vFitFlood(2);
            UEbb   = rangeRatiosPerTimeStep.*scaledTS.uTidal + (1-rangeRatiosPerTimeStep).*uFitEbb(2);
            VEbb   = rangeRatiosPerTimeStep.*scaledTS.vTidal + (1-rangeRatiosPerTimeStep).*vFitEbb(2);

            scaledTS.uTidal = UFlood;
            scaledTS.vTidal = VFlood ;
            
            ebbIdxs = ttWaterLevel.gradient < 0;
            
            scaledTS.uTidal(ebbIdxs) = UEbb(ebbIdxs);
            scaledTS.vTidal(ebbIdxs) = VEbb(ebbIdxs) ;
            
            [scaledTS.SpeedTidal, scaledTS.DirectionTidal] = RCM.Utils.uv2spd(scaledTS.uTidal,scaledTS.vTidal);
            
            scaledTS.u = scaledTS.uTidal + scaledTS.uNonTidal;
            scaledTS.v = scaledTS.vTidal + scaledTS.vNonTidal;
            
            [scaledTS.Speed, scaledTS.Direction] = RCM.Utils.uv2spd(scaledTS.u,scaledTS.v); 
            
            meanPressure = mean(scaledTS.Pressure);
            scaledTS.Pressure = ttWaterLevel.Height + meanPressure;
            scaledTS.clearDerivedProperties;
            
            figure
            subplot(211)
            plot(scaledTS.uTidal); grid on
            subplot(212)
            plot(scaledTS.vTidal); grid on
            
            figure
            subplot(211)
            plot(scaledTS.u); grid on
            subplot(212)
            plot(scaledTS.v); grid on
            
            figure
            subplot(211)
            plot(scaledTS.Speed); grid on
            subplot(212)
            plot(scaledTS.Direction); grid on
        end

         
        function [str] = toStruct(TS)
            % Returns a struct representation of the object.
            
            str = struct(TS);
        end
        
        function [str] = toArchiveStruct(TS)
            % Returns a struct representation of the object with the names
            % of some fields changed to be consistent with OceanMet archive
            % conventions
            
            str = TS.toStruct;
            
            aliases = {...
                'Time',      'timeGmt';...
                'Speed',     'speed';...
                'Direction', 'directionMagnetic';...
                'u',         'velocityU';...
                'v',         'velocityV';
                'Pressure',  'pressureDepth'...
                };
            
            for i = 1:size(aliases,1)
                str.(aliases{i,2}) = str.(aliases{i,1});
                str = rmfield(str, aliases{i,1});
            end            
        end
        
    end
    
    methods (Access = protected)
        
        function calculateComponents(TS)
            [TS.u, TS.v] = RCM.Utils.spd2uv(TS.Speed, TS.Direction);
        end
        
        function calculateSpeed(TS)
            [TS.Speed,TS.Direction] = RCM.Utils.uv2spd(TS.u,TS.v); 
        end
    end
    
end

